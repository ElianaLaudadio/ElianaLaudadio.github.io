<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>About Me &#x1F469;&zwj;&#x1F4BB;</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="">
    <script src=""></script>
</head>
<body style="background-color:#FCFBF4;">

<div style="display: flex; justify-content: space-between; align-items: center; font-size: 30px; border-bottom: 1px solid black;">
    <header style="font-size: 50px; margin-left: 1in; margin-right: 20px;">ELIANA LAUDADIO</header>
    <div style="text-align: right;">
        <a href="/Users/elianalaudadio/Desktop/Portfolio/index.html" style="text-decoration: none;">
            <button style="background: none; border: none; font-size: 22px; margin-left: 20px; cursor: pointer;"
                    onmouseover="this.style.border='2px solid black';"
                    onmouseout="this.style.border='none';">HOME</button>
        </a>
        <a href="/Users/elianalaudadio/Desktop/Portfolio/portfolio.html" style="text-decoration: none;">
            <button style="background: none; border: none; font-size: 22px; margin-left: 20px; cursor: pointer;"
                    onmouseover="this.style.border='2px solid black';"
                    onmouseout="this.style.border='none';">PORTFOLIO</button>
        </a>
        <a href="/Users/elianalaudadio/Desktop/Portfolio/aboutme.html" style="text-decoration: none;">
            <button style="background: none; border: none; font-size: 22px; margin-left: 20px; cursor: pointer;"
                    onmouseover="this.style.border='2px solid black';"
                    onmouseout="this.style.border='none';">ABOUT ME</button>
        </a>
    </div>
</div>

<div style="margin: 20px; margin-left: 1in;">
    <div style="font-weight: bold; font-size: 25px;">ARRAY LISTS</div>
    <p>An ArrayList is a resizable array implementation in Java that allows dynamic storage and manipulation of elements, enabling efficient addition and removal after the compilation phase, while storing reference types.</p>
    <ul>
        <li>Where arrays are a fixed allocation size, ArrayLists can grow or shrink dynamically to contain desired elements</li>
        <li>Does not support primitive data types; only use reference types</li>
        <li>Supports random access; elements can be accessed directly rather than in a fixed sequence</li>
        <li>Runtime Complexity: </li>
    </ul>

    <p style="font-weight: bold;">Simple ArrayList Methods:</p>
    <ul>
        <li>add(element): adds element at the end of the list</li>
        <li>remove(index): removes element at desired index</li>
        <li>get(index): returns element at desired index</li>
        <li>set(index, element): sets desired index with desired element</li>
        <li>size(): returns the size of the arraylist</li>
    </ul>
    <div style="margin: 20px;">
        <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px;">

    
<code>
    import java.util.ArrayList;                             // enables use of ArrayList

    public class Main {
    
        public static void main(String[] args) {
            
            ArrayList<String> grocery = new ArrayList<String>();            // creates reference variable that refers to a new ArrayList object consisting of String objects.
            
            grocery.add("milk");
            grocery.add("eggs");
            grocery.add("cheese");
            
            grocery.set(0, "low fat milk");
            grocery.remove(2);
            grocery.clear();
            
            for(int i = 0; i < grocery.size(); i++) {       //printing and iterating
                System.out.println(grocery.get(i));
            }
        }
    }
</code>
        </pre>
    </div>



    <p style="font-weight: bold;">When to use Array Lists:</p>
    <ol>
        <li>When you need a list that can grow or shrink dynamically</li>
        <li>Supports random access</li>
    </ol>

<!--------------------------------------------------------------------------------------------------------->

    <div style="font-weight: bold; font-size: 25px; font-family: 'Times New Roman', Times, serif;">LINKED LISTS</div>
    <p>A linked list is a data structure consisting of a collection of nodes, where each node contains a data field and a reference (link) to the next node in the sequence.</p>
    <p style="font-weight: bold;">How they work</p>
    <p>A linked list is made up of a chain of nodes, each node contains an element and the address of the next node. In technicality, each node can live anywhere in memory, but these sequential pointers in each node links all of the elements into a list. Each Linked List has a head at the first element where it starts, and ends with the last element that points to "null". To add or remove the nodes, you simply manipulate the neighboring node pointers rather than iterating shifting elements around until you get your desired list.</p>


    <ul>
        <li>Makes the process of adding or removing in the middle of a list much faster</li>
        <li>Supports random access; elements can be accessed directly rather than in a fixed sequence</li>
        <li>Not reliable with searching long lists since you have to start at the head of the list and iterate through.</li>
        <li>The process explained above is a "singly-linked list", however, a second process called a "doubly linked list" adds a pointer to the previous node allowing easy access both forwards and backwards in the list.</li>
    </ul>

    <p style="font-weight: bold;">Simple Linked List Methods:</p>
    <ul>
        <li>add(element): adds element at the end of the list</li>
        <li>remove(index): removes element at desired index</li>
        <li>get(index): returns element at desired index</li>
        <li>set(index, element): sets desired index with desired element</li>
        <li>size(): returns the size of the arraylist</li>
    </ul>
    <div style="margin: 20px;">
        <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px;">

    
<code>
    import java.util.LinkedList;

    public class MyClass {
        public static void main(String[] args) {
            LinkedList<String> list = new LinkedList<String>();
            list.add("milk");
            list.add("eggs");
            list.add("cheese");

            list.remove("cheese")

            System.out.println(list.indexOf("eggs"));
    
            System.out.println(list);
        }
    }

//                                     SINGLY LINKED LISTS
//                       Node                  Node                Node
//            [data] | [address] -> [data] | [address] -> [data] | [null]


//                                     DOUBLY LINKED LISTS
//             Node                            Node                               Node
//[null] | [data] | [address] <-> [address] | [data] | [address] <-> [address] | [data] | [null]



</code>
        </pre>
    </div>



    <p>When to use Linked Lists:</p>
    <ol>
        <li>When you need a list that can grow or shrink dynamically</li>
        <li>Supports random access</li>
    </ol>







    <div style="font-weight: bold; font-size: 25px; font-family: 'Times New Roman', Times, serif;">STACKS</div>
    <p>A stack is a last in, first out data structure. They allow us to store objects into a logical vertical tower.</p>
    <p style="font-weight: bold;">How they work</p>
    <p>Think of a stack of books, the last book you place on the top of stack is also going to be the first one you will grab when you take one away. In this case, in order to access a object at the bottom of the stack, you would first have to remove each object at the top one by one.</p>


    <ul>
        
        <li>Stacks operate on a Last In, First Out (LIFO) basis, meaning the last element added is the first one to be removed.</li>
        <li>Stack indexs start at 1; if you search for the element at the first index, it will return 1.</li>
        <li>Stacks can grow and shrink in size dynamically, depending on the number of elements they contain, especially when implemented using linked lists.</li>
        <li>Stacks do not allow random access to elements; you can only access the top element directly.</li>
    </ul>

    <p style="font-weight: bold;">Simple Stack Methods:</p>
    <ul>
        <li>push(element): adds element to the top of the stack</li>
        <li>pop(): removes element at the top of the stack</li>
        <li>peek(): returns element at top of the stack</li>
        <li>empty(): returns a boolean true or false whether the stack is empty or not</li>
        <li>search(element): returns the location of the element.</li>
    </ul>
    <div style="margin: 20px;">
        <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px;">

    
<code>
    import java.util.Stack;

    public class MyClass {
        public static void main(String[] args) {
            Stack<String> stack = new Stack<String>();

            System.out.println(stack.empty());
            stack.push("cheese");
            stack.push("eggs");
            stack.push("milk");

            stack.pop();

            System.out.println(stack.peek());
    
            System.out.println(stack);
        }
    }

//                                     STACK EXAMPLE
//            [cheese]             
//            [eggs], [cheese]
//            [milk], [eggs], [cheese]
//            [eggs], [cheese]



</code>
        </pre>
    </div>



    <p style="font-weight: bold;"> When to use Stacks:</p>
    <ol>
        <li>Any time you need to backtrack through a browser, list, or workflow</li>
        <li>In graph algorithms, DFS can be implemented using a stack to keep track of the nodes to be explored.</li>
        <li>Stacks can be used to implement undo functionality in applications (e.g., text editors), where the last action can be reverted.</li>
    </ol>



    <div style="font-weight: bold; font-size: 25px; font-family: 'Times New Roman', Times, serif;">QUEUES</div>
    <p>A queue is similar to a stack, but instead it is a first in, first out (FIFO) data structure. Queues allow us to store objects into a line.</p>
    <p style="font-weight: bold;">How they work</p>
    <p>Think of that line you waited in at the bank, that felt like it took hours. No matter how long you were there and what priorities you had, you had to wait for the people in front of you to go one by one. This is exactly how a queue works, the first person to get to get in the bank line will leave first, and so on.</p>


    <ul>
        
        <li>Queues operate on a First In, First Out (FIFO) basis, meaning the first element in the queue will be the first one to be removed.</li>
        <li>Queues can grow and shrink in size dynamically, depending on the number of elements they contain, especially when implemented using linked lists.</li>
        <li>Queues do not allow random access to elements; you can only access the top element directly.</li>
        <li>The conecept of adding to a queue is called "enqueue", while removing from the queue is dequeue</li>
    </ul>

    <p style="font-weight: bold;">Simple Queue Methods:</p>
    <ul>
        <li>offer(element): adds element to the top of the stack, also known as enqueue</li>
        <li>pull(): removes first element that was put into the queue, also known as dequeue</li>
        <li>peek(): returns first element that was put in the queue, but does not remove it</li>
        <li>empty(): returns a boolean true or false whether the queue is empty or not</li>
        <li>contains(element): returns if the element is in the queue.</li>
    </ul>
    <div style="margin: 20px;">
        <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px;">

    
<code>
    import java.util.LinkedList;
    import java.util.Queue;

    public class MyClass {
        public static void main(String[] args) {
            Queue<String> queue = new LinkedList<String>();

            System.out.println(queue.empty());
            queue.offer("cheese");
            queue.offer("eggs");
            queue.offer("milk");

            queue.pull();

            System.out.println(queue.peek());
    
            System.out.println(queue);
        }
    }

//                                     QUEUE EXAMPLE
//            
//            
//            
//            



</code>
        </pre>
    </div>



    <p style="font-weight: bold;"> When to use Queues:</p>
    <ol>
        <li>In scenarios where data is produced and consumed at different rates (like streaming applications), queues can act as buffers to hold data temporarily.</li>
        <li>In graph algorithms, queues are used to explore nodes level by level, making them essential for BFS traversal.</li>
        <li>Managing tasks that need to be executed in the order they arrive.</li>
    </ol>







    <div style="font-weight: bold; font-size: 25px; font-family: 'Times New Roman', Times, serif;">PRIORITY QUEUES</div>
    <p>A  priority queue is similar to a regular queue, as it is a first in, first out (FIFO) data structure. Queues allow us to store objects into a line, however priority queues allow us to give weight and order to each element.</p>
    <p style="font-weight: bold;">How they work</p>
    <p>In simple terms, priority queues work the same as queues as you add in each element. However with priority queues, we want to sort the elements in the queue before we begin the dequeue process. So, say you enter 3, 5, 1, 4, 2, but you want to give priority to the lowest numbers first, we will sort the list into 1, 2, 3, 4, 5 and then begin treating the list as if it were a normal queue; allowing 1 to be dequeued first.</p>


    <ul>
        
        <li>Priority Queues operate on a First In, First Out (FIFO) basis, meaning the first element in the queue will be the first one to be removed.</li>
        <li>Using strings in priority queues alphabetizes them</li>
        <li>Priority Queues use Heaps to sort the contents/li>
        <li>Priority Queues can grow and shrink in size dynamically, depending on the number of elements they contain, especially when implemented using linked lists.</li>
        <li>Priority Queues do not allow random access to elements; you can only access the top element directly.</li>

    </ul>

    <p style="font-weight: bold;">Simple Priority Queues Methods:</p>
    <ul>
        <li>offer(element): adds element to the top of the stack, also known as enqueue</li>
        <li>pull(): removes first element that was put into the queue, also known as dequeue</li>
        <li>peek(): returns first element that was put in the queue, but does not remove it</li>
        <li>empty(): returns a boolean true or false whether the queue is empty or not</li>
        <li>contains(element): returns if the element is in the queue.</li>
    </ul>
    <div style="margin: 20px;">
        <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px;">

    
<code>
    import java.util.LinkedList;
    import java.util.Queue;

    public class MyClass {
        public static void main(String[] args) {
            Queue<Integer> priority_queue = new PriorityQueue<Integer>();    //"Collections.reverseOrder()" method to go from biggest to smallest element instead

            System.out.println(priority_queue.empty());
            priority_queue.offer(3);
            priority_queue.offer(5);
            priority_queue.offer(1);
            priority_queue.offer(4);
            priority_queue.offer(2);


            System.out.println(priority_queue.peek());
    
                while(!priority_queue.isEmpty()){
                    System.out.println(priority_queue);              // This would print 1,2,3,4,5
                }



        }
    }

//                                     PRIORITY QUEUE EXAMPLE
//            [cheese]             
//            [eggs], [cheese]
//            [milk], [eggs], [cheese]
//            [eggs], [cheese]



</code>
        </pre>
    </div>



    <p style="font-weight: bold;"> When to use Priority Queues:</p>
    <ol>
        <li>In operating systems or job scheduling, processes with higher priority may need to be executed before lower-priority ones.</li>
        <li>In data compression, a priority queue is used to build the Huffman tree by repeatedly combining the two least frequent elements.</li>
        <li> In real-time systems where certain tasks must be completed within strict time constraints, priority queues can help ensure that high-priority tasks are handled promptly.</li>
    </ol>




    <div style="font-weight: bold; font-size: 25px; font-family: 'Times New Roman', Times, serif;">BINARY TREES</div>
    <p>A binary tree is a data structure made up of nodes, where each node has at most two children, referred to as the left and right child. It is often used to organize data hierarchically, allowing for efficient searching, inserting, and deleting of elements.</p>
    <p style="font-weight: bold;">How they work</p>
    <p>Binary trees work by linking nodes together, with each node containing a value and pointers to its left and right children. When you want to find, add, or remove a node, you start at the root and follow the links left or right based on comparisons until you reach the desired position.</p>


    <ul>
        
        <li>Searching a binary tree: Searching through a binary tree involves starting at the root and comparing the target value to each node, moving left for smaller values and right for larger values until the target is found or a leaf node is reached.</li>
        <li>Adding to a binary tree: To add a value to a binary tree, start at the root and compare the new value to the current node's value. If the new value is smaller, move to the left child; if it's larger, move to the right child. Repeat this process until you find an empty spot (a null child), where you can insert the new value as a new node.</li>
        <li>Removing from a binary tree: Removing a value from a binary tree involves three main steps: first, locate the node with the value to be removed by traversing the tree. If the node has no children, simply remove it; if it has one child, replace the node with its child. If the node has two children, find the node's in-order successor (the smallest value in its right subtree), replace the target node's value with that successor, and then remove the successor node from its original position.</li>

    </ul>

    <p style="font-weight: bold;">Tree Vocabulary:</p>
    <ul>
        <li>"Tree": Non-linear data structure where nodes are organized into a heirarchy</li>
        <li>"Root": Top node of the tree; does not have any incoming edges</li>
        <li>"Leaf": Any nodes at the bottom of the tree that do not have any outgoing edges</li>
        <li>"Parent Nodes": Nodes that have outgoing edges</li>
        <li>"Child Nodes": Nodes that have incoming edges </li>
        <li>"Internal Node": A node with at least one child</li>
        <li>"Siblings": Any child nodes that share the same parent nodes</li>
        <li>"Sub-Tree": Smaller tree within a larger tree </li>
        <li>"Size": Tree size is equal to the number of nodes</li>
        <li>"Depth": Tree deph is the number of edges below the root node. The root starting at 0.</li>
        <li>"Height": Tree height is the number of edges above the furthest leaf node.</li>
    </ul>

    <p style="font-weight: bold;">Binary Tree Specifics</p>
    <ul>
        <li>Each node has no more than 2 childeren</li>
        <li>"Full": A binary tree is full if every node contains 0 or 2 children</li>
        <li>"Complete": A binary tree is complete if all levels, except possibly the last level, contain all possible nodes and all nodes in the last level are as far left as possible.</li>
        <li>"Perfect": A binary tree is perfect, if all internal nodes have 2 children and all leaf nodes are at the same level</li>

    </ul>
    <div style="margin: 20px;">
        <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px;">

    
<code>

//    a example of a simple tree:

//          [1]                      - 1 is the root, and the parent node of 2 and 3
//         /   \                     - these connections between nodes are edges
//       [2]   [3]                   - 2 and 3 are internal nodes that are siblings of eachother
//      / \    / \
//    [4] [5][6] [7]                 - All of these nodes are childeren of either 2 or 3. Since they themselves
//                                    do not have childeren, they are leaf nodes
//
//                                   - The numbers in this tree represent the order of indices in list form


//----------------------------------------------------------------------
//SEARCHING A TREE

//          [4]                      - Given this tree, lets search for the element '5'
//    (<)  /   \  (>)                - 1. First we will compare it to index 0, which is element '4' (Always start with the root node)
//       [2]   [6]                        -  5 > 4, so we will traverse to the right half of the tree
//      / \    / \                   - 2. Now, we will compare '5' to the right child of '4', which is element '6'
//    [1] [3][5] [7]                      - 5 < 6, so we will traverse to the left of element '6'
//                                   - 3. Now we will compare '5' to the left element of '6'
//                                        - 5 == 5, we have found our element at index 6.

//----------------------------------------------------------------------
//ADDING TO A TREE

//          [4]                      - Given this tree, lets insert the element '9'
//    (<)  /   \  (>)                - 1. First we will compare it to index 0, which is element '4' (Always start with the root node)
//       [2]   [6]                        -  9 > 4, so we will traverse to the right half of the tree
//      / \    / \                   - 2. Now, we will compare '9' to the right child of '4', which is element '6'
//    [1] [3][5] [7]                      - 9 > 6, so we will traverse to the right of element '6'
//                                   - 3. Now, we will compare '9' to the right child of '6', which is element '7'
//                                        - 9 > 7, so we will place '9' to the right of element '7'

    

//          [4]                      - Tree after adding element '9'
//    (<)  /   \  (>)                
//       [2]   [6]                       
//      / \    / \                   
//    [1] [3][5] [7]  
//                 \
//                 [9]

//          [4]                      - Tree after adding element '8'
//    (<)  /   \  (>)                
//       [2]   [6]                       
//      / \    / \                   
//    [1] [3][5] [7]  
//                 \
//                 [9]
//                /
//              [8]

//----------------------------------------------------------------------
//REMOVNG FROM A TREE

//          [4]                      - There are 3 different cases when it comes to removal of a BST:
//    (<)  /   \  (>)                   1. Removing a leaf node; if we remove '8', then the child of element '9' becomes 'null'
//       [2]   [6]                       
//      / \    / \                   
//    [1] [3][5] [7]  
//                 \
//                 [9]


//          [4]                      
//    (<)  /   \  (>)                   2. Removing an internal node with one child; if we remove '7', then '9' will take its place
//       [2]   [6]                       
//      / \    / \                   
//    [1] [3][5] [9]  

            
//          [5]                      
//    (<)  /   \  (>)                   3. Removing an internal node with two childeren; if we remove '4', then we want to replace it
//       [2]   [6]                         with its left-most child in it's right subtree, in this case, it would be element '5'
//      / \    / \                   
//    [1] [3]    [9]  


</code>
        </pre>
    </div>



    <p style="font-weight: bold;"> When to use Binary Trees:</p>
    <ol>
        <li>When data is naturally hierarchical, such as file systems, organization charts, or classification trees.</li>
        <li>For representing and evaluating mathematical expressions, where leaf nodes are operands and internal nodes are operators.</li>
    </ol>

    <div style="font-weight: bold; font-size: 25px; font-family: 'Times New Roman', Times, serif;">HEAPS</div>
    <p>My number one rule when studying any computer science topic is to not ask too many questions. Simply, do not think too much and take each topic as it comes and one step at a time. In this sense, if you have been flowing through these data structures as so, you did not take a moment to ask yourself how queues become sorted into priority queues. As we are taking information as it comes; it has come time to satisfy some curiosity and to discuss heaps.</p>
    <p style="font-weight: bold;">How they work</p>
    <p>Simply put, heaps are binary trees! When you create a priority queue out of a queue, it simply creates a min or max heap to order your elements. Keep it simple!</p>









    <div style="font-weight: bold; font-size: 25px; font-family: 'Times New Roman', Times, serif;">HASH TABLES</div>
    <p>A hash table is a data structure that stores key-value pairs, allowing for fast access to values based on their unique keys.</p>
    <p style="font-weight: bold;">How they work</p>
    <p>Hash tables use a hash function to convert each key into a unique index, which determines where the corresponding value is stored in an underlying array. This allows for quick access to values, but if two keys hash to the same index (a collision), the hash table must handle it using techniques like chaining (storing multiple values at that index in a list) or open addressing (finding another index). Despite potential collisions, hash tables are efficient and commonly used for tasks like database indexing and caching.</p>


    <ul>
        
        <li>Chaining: Chaining is a collision handling method in hash tables where, if two keys hash to the same index, both values are stored in a list at that index. This allows multiple values to coexist and be accessed by searching through the list. </li>
        <li>Open Addressing: Open addressing is a collision resolution method in hash tables where, if an index is occupied, the table finds the next available index using a probing sequence, storing each key directly in the array. </li>
       

    </ul>

    <p style="font-weight: bold;">Hash Table Vocabulary:</p>
    <ul>
        <li>"Entry<K,E>": Key, Element pair</li>
        <li>"Hash code method": A method that takes a key, runs it through a specific formula, and returns a hash value.</li>
        <li>"Hash": Integer given from a hash code method</li>


    </ul>


    <div style="margin: 20px;">
        <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px;">

    
<code>

// A QUICK HASH TABLE
//      Entry<K,V>                              Hash Method      Hash Table (capacity = 5)
//                                         K % capacity
//
//      100, "milk"                           100 % 5  = 0              0[100, milk]
//      154, "eggs"                           154 % 5  = 4              1[679, bacon]
//      247, "cookies"                        247 % 5  = 2              2[247, cookies]
//      679, "bacon"                          671 % 5  = 1              3[]
//                                                                      4[154, eggs]
//                                                                   
//
//----------------------------------------------------------------------
// CHAINING
//
//      Entry<K,V>                              Hash Method      Hash Table (capacity = 5)
//                                         K % capacity
//
//      100, "milk"                           100 % 5  = 0              0[100, milk], [200, cat food]
//      154, "eggs"                           154 % 5  = 4              1[679, bacon]
//      247, "cookies"                        247 % 5  = 2              2[247, cookies]
//      679, "bacon"                          671 % 5  = 1              3[]
//      200, "cat food"                       200 % 5  = 0              4[154, eggs]


//----------------------------------------------------------------------
// OPEN ADDRESSING
//



</code>
        </pre>
    </div>



    <p style="font-weight: bold;"> When to use Hash Tables</p>
    <ol>
        <li>When you need quick access to data using a unique key, such as retrieving user information by user ID.</li>
        <li>For caching; storing frequently accessed data to speed up retrieval, such as memoization in algorithms.</li>
    </ol>




    <div style="font-weight: bold; font-size: 25px; font-family: 'Times New Roman', Times, serif;">GRAPHS</div>


</div>


</body>
</html>
